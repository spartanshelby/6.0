 Finding a hidden parameter is just step one; the critical step is testing it to see if it's vulnerable.
 
### 1. Insecure Direct Object References (IDOR) - The Most Common Find

This is the most likely vulnerability you'll find with a parameter like `user_id`.

*   **What to do:** If the `user_id` parameter is used to fetch or display user-specific data, change its value to that of another user.
    *   **Example:** You are user `12345`. The hidden parameter is `<input type="hidden" name="user_id" value="12345">`. Change `POST` or `GET` data to `user_id=67890`.

### 2. Privilege Escalation

Sometimes, `user_id` or similar parameters might be used for authorization checks.

*   **What to do:** If you find a hidden parameter like `role`, `is_admin`, `access_level`, or even `user_id` pointing to an administrator, try manipulating it.
    *   **Example:** You find `user_id=5` and you suspect `user_id=1` is the admin. Change the value to `1`.

### 3. Parameter Pollution & Business Logic Flaws `user_id=12345&user_id=67890`. 



1.  **Identify the Request:** Note which request (e.g., `POST /update_profile`) contains the hidden `user_id` parameter.
2.  **Baseline the Response:** Send the normal request and note the response.
3.  **Modify and Observe:**
    *   **Change the value:** Increment/decrement it (`12345` -> `12346`). Do you see another user's data?
    *   **Fuzz for SQLI:** Send `user_id=12345'`, `user_id=12345 SLEEP(5)-- -`, etc. Look for errors or delays.
    *   **Fuzz for XSS:** Send `user_id=<img src=x onerror=alert('XSS')>`.
    *   **Break the Logic:** Send negative numbers, huge numbers, or non-integers.
    *   **Check for Mass Assignment:** Add a new parameter like `&is_admin=true` to the request *along with* the changed `user_id`.
4.  **Automate (Optional):** Use Burp Intruder to quickly test a list of common user IDs (e.g., 1 through 1000) to scan for accessible records.

**In summary: A hidden parameter is a direct invitation to test the application's trust boundaries. Your job is to answer the question: "What happens if I change this?" The answer could be nothing, or it could be a critical vulnerability.**









what do i do with hidden endpoints,parameters. how to combine those to find bugs
Of course! This is a critical skill for advanced bug hunting, especially in API security. Finding hidden endpoints and parameters is like getting the "developer's edition" of the application, revealing functionality that wasn't meant for public eyes.

Let's break this down into a systematic process.

### Part 1: Finding Hidden Endpoints & Parameters

You can't test what you can't see. Here’s how to discover them.

#### A) Finding Hidden Endpoints

Endpoints are the doors to the application's functionality (e.g., `/api/v1/users`).

1.  **Passive Reconnaissance (The Quiet Approach):**
    *   **JavaScript Files:** This is the #1 source. Use your browser's DevTools (F12 -> Sources/Network) or a tool like **Burp's "JS Miner"** extension to scan all `.js` files. Look for:
        *   `fetch()`, `axios.get()`, `$.ajax()` calls.
        *   Strings that look like paths: `/api/admin/deleteUser`, `/internal/exportData`.
    *   **Source Code Repositories:** Search GitHub, GitLab, etc., for the target's name. Developers often leave API keys, test endpoints, and internal paths in commits. Use tools like **GitHunter** or manual dorking (e.g., `"target.com" AND "api/v1"`).
    *   **Archived Pages:** Use the **Wayback Machine** (`web.archive.org`). Old versions of the site might have endpoints that are still live but no longer linked.

2.  **Active Reconnaissance (The Knocking Approach):**
    *   **Wordlists & Fuzzing:** Use tools like **ffuf**, **gobuster**, or **DirSearch** with massive API/endpoint wordlists.
        *   **Popular Wordlists:** `raft-large-directories.txt`, `SecLists/Discovery/Web-Content/`, `api-wordlist` from SecLists.
        *   **Targeted Fuzzing:** If you find `/api/v1/users`, fuzz for `/api/v1/admin`, `/api/v1/config`, `/api/v2/users`, etc.
    *   **Virtual Host Enumeration:** Sometimes, `api.internal.target.com` is different from `www.target.com`. Fuzz for subdomains using tools like **Amass**, **Subfinder**, or **ffuf**.

#### B) Finding Hidden Parameters

Parameters are the knobs and levers for those doors (e.g., `?id=1&debug=true`).

1.  **Passive Reconnaissance:**
    *   **JavaScript Files (Again):** Look for variable names in functions. Parameters like `isAdmin`, `debug`, `test`, `export`, `callback` are often hardcoded.
    *   **HTTP Archive Files (.har):** If you can get a HAR file from a developer or generate one during normal use, it can reveal parameters used by the live application.

2.  **Active Reconnaissance:**
    *   **Parameter Mining with Arjun:** **This tool is a game-changer.** Arjun (`arjun -u <url>`) is specifically designed to find hidden parameters by using a massive list of common parameter names and sending specially crafted requests to identify which parameters are actually accepted by the endpoint.
    *   **Wordlist Fuzzing:** Use `ffuf` or `Burp Intruder` with parameter wordlists (e.g., `SecLists/Discovery/Web-Content/burp-parameter-names.txt`).
    *   **Analyzing Similar Endpoints:** If `/api/v1/users/1` has parameters `name` and `email`, try those same parameters on `/api/v1/admin/logs`.

---

### Part 2: The "How to Combine" - A Methodology for Finding Bugs

Now for the fun part. You have a list of hidden endpoints and parameters. Here’s a structured way to combine them to find vulnerabilities.

#### Step 1: Categorize and Prioritize

*   **Endpoints:**
    *   **Admin:** `/admin/deleteUser`, `/api/internal/config`
    *   **User:** `/api/v2/profile/upgrade`
    *   **Utility:** `/debug`, `/export`, `/backup`
*   **Parameters:**
    *   **Functional:** `debug`, `test`, `format`, `callback`
    *   **Privilege:** `is_admin`, `role`, `user_id`
    *   **Destructive:** `delete`, `overwrite`, `purge`

**Priority #1:** Combine **Admin/Destructive Endpoints** with **Privilege Parameters.**

#### Step 2: The Testing Matrix - Common Bug Scenarios

| Hidden Endpoint (Found via Fuzzing) | Hidden Parameter (Found via Arjun/JS) | How to Combine & Test for Bugs |
| :--- | :--- | :--- |
| **`/api/admin/createUser`** | **`role`** | **Broken Access Control (BAC):** Can a low-privileged user access this endpoint? If so, can they set `?role=admin` to create an admin user? |
| **`/api/v1/user/[id]`** | **`is_admin`** | **BAC / IDOR:** Change the `[id]` to another user's ID. Does the `is_admin=true` parameter now make *that* user an admin? |
| **`/api/logs`** | **`format`** | **Server-Side Request Forgery (SSRF):** Try `?format=https://yourburpcollaborator.com`. **Command Injection:** Try `; whoami` or `| ls /`. |
| **`/api/exportData`** | **`debug`** | **Information Disclosure:** `?debug=true` might reveal stack traces, API keys, or internal system paths. |
| **`/api/graphql`** (a common hidden endpoint) | **(Any GraphQL field)** | **GraphQL-specific:** Use **InQL** (Burp Extension). Try introspection queries to map the entire schema. Look for mutations (actions like `deletePost`) that you shouldn't have access to. |
| **Any JSON endpoint** | **`callback`** | **JSONP / XSS:** If the endpoint returns JSON, adding `?callback=alert(1)` might reflect your input, leading to XSS. |
| **`/api/search`** | **`query`** | **SQL Injection (SQLi):** Fuzz the `query` parameter with SQLi payloads. **NoSQLi:** If it's a NoSQL DB, try `?query[$ne]=null`. |

#### Step 3: Practical Attack Walkthrough

Let's imagine you found the following:

*   **Endpoint:** `/api/internal/userExport` (found by fuzzing JS files)
*   **Parameter:** `filename` (found by using Arjun on the endpoint)

**Your attack process:**

1.  **Understand the Function:** It likely exports user data into a file.
2.  **Test for Path Traversal:**
    *   `GET /api/internal/userExport?filename=../../../../etc/passwd`
    *   `GET /api/internal/userExport?filename=..\..\..\windows\system32\drivers\etc\hosts`
3.  **Test for Command Injection:**
    *   `GET /api/internal/userExport?filename=report.pdf; whoami`
    *   `GET /api/internal/userExport?filename=report.pdf | cat /etc/passwd`
4.  **Test for SSRF:** Could it fetch a file from a URL?
    *   `GET /api/internal/userExport?filename=http://169.254.169.254/latest/meta-data/` (AWS Metadata)
5.  **Test for Access Control:** Can a non-admin user access this endpoint? Try it without an admin session.

### Essential Toolbox

*   **Proxy & Scanner:** **Burp Suite Professional** (with Autorize, JS Miner, InQL extensions) or **OWASP ZAP**.
*   **Fuzzer:** **ffuf** (fast, command-line) or **Burp Intruder**.
*   **Parameter Discovery:** **Arjun**.
*   **Wordlists:** **SecLists** repository.
*   **Collaborator:** **Burp Collaborator** or **Interactsh** for detecting blind vulnerabilities (SSRF, Blind SQLi, Out-of-band Command Injection).

### Final Pro Tips

*   **Don't Trust Client-Side Controls:** Hidden parameters often bypass client-side validation. Even if the UI doesn't have a "role" field, the backend might still accept it.
*   **Think Like a Developer:** Why would an endpoint/parameter be hidden? It's often for internal use, debugging, or admin functions. These are prime targets for privilege escalation.
*   **Automate, but Also Manual Test:** Automate the discovery, but the exploitation often requires manual, creative testing to understand the application's logic.
*   **Chain Findings:** A hidden `debug` parameter that gives you more information can help you exploit a hidden `admin` endpoint you found elsewhere.

By systematically discovering hidden assets and then strategically combining them to test for common vulnerability patterns, you dramatically increase your chances of finding severe, business-logic flaws that automated scanners will never see.










i have a lot of hidden endpoints from target domains and subdomain. how to categories and find bug

Of course. This is an excellent position to be in. A large, unorganized list of endpoints is a goldmine for a bug hunter. The key is to move from chaos to a structured, methodical testing process.

Here’s a comprehensive guide on how to categorize your endpoints and systematically find bugs.

### Phase 1: Categorization & Prioritization

First, you need to make sense of the list. Don't just start testing randomly.

#### Step 1: Parse and Normalize Your Data
Use a tool or a simple script to parse your list. Extract the following for each endpoint:
*   **Full URL**
*   **Domain/Subdomain**
*   **Path** (e.g., `/api/v1/user/profile`)
*   **HTTP Method** (if known, e.g., GET, POST, PUT)
*   **Parameters** (if known, e.g., `?id=123`, `{user_id}` in the path)

#### Step 2: Categorize by Functionality and Sensitivity
Create folders or lists for these categories. This is the most critical step for efficient testing.

1.  **Authentication & Authorization Endpoints:**
    *   `/login`, `/logout`, `/register`, `/reset-password`, `/oauth/authorize`
    *   **Why:** Prime targets for bypasses, brute-force, and logic flaws.

2.  **User-Specific & Profile Endpoints:**
    *   `/api/v1/users/{id}/profile`, `/api/v1/users/{id}/settings`, `/my-account`
    *   **Why:** High probability for **IDOR** (Insecure Direct Object Reference).

3.  **Administrative Endpoints:**
    *   `/admin/`, `/api/admin/deleteUser`, `/cpanel`, `/debug`
    *   **Why:** Often have powerful functions. Look for **broken access control** (can a regular user access them?).

4.  **File Operation Endpoints:**
    *   `/upload`, `/download`, `/attachments/{id}`, `/export`
    *   **Why:** Targets for **Path Traversal**, **XXE**, and Unrestricted File Upload.

5.  **API Endpoints (REST/GraphQL):**
    *   Anything under `/api/`, `/graphql`, `/v1/`, `/v2/`
    *   **Why:** Rich sources for **mass assignment**, **injection**, **broken object level authorization** (BOLA/IDOR in APIs), and rate-limiting issues.

6.  **Search and Query Endpoints:**
    *   `/search`, `/query`, `/lookup?q=`
    *   **Why:** Classic targets for **SQL Injection** (SQLi), **NoSQL Injection**, and **XSS**.

7.  **Payment and Order Processing Endpoints:**
    *   `/checkout`, `/api/process-payment`, `/cart/applyCoupon`
    *   **Why:** Business logic flaws (e.g., negative prices, coupon reuse).

8.  **Miscellaneous & "Weird" Endpoints:**
    *   `/debug/pprof`, `/backup/`, `/test/`, `/old/`, `/phpinfo.php`
    *   **Why:** These often expose sensitive information or are misconfigured.

#### Step 3: Prioritize Your Testing
Don't test all categories with the same intensity at once.
*   **High Priority:** Authentication, Administrative, Payment, and User-Specific endpoints. These have the highest impact.
*   **Medium Priority:** File Operations, API Endpoints.
*   **Low Priority:** Search endpoints, miscellaneous ones.

---

### Phase 2: The Hunting Methodology

Now, with your categorized list, start the systematic hunt.

#### Step 1: Passive Reconnaissance (Without Sending Malicious Payloads)
*   **Spidering/Crawling:** Feed your endpoints into a tool like **Burp Suite's Scanner** or **OWASP ZAP** to let it discover more links and content.
*   **Check for Sensitive Information:**
    *   Access each endpoint with a `GET` request. Look for:
        *   Hardcoded credentials (API keys, passwords) in JavaScript files or comments.
        *   Information disclosure (stack traces, server versions, internal IPs).
    *   Check for backup files (e.g., `.bak`, `.old`, `.zip` versions of the endpoint).

#### Step 2: Active Testing (The Core Work)

**A. Test for Broken Access Control & IDOR:**
*   **For User-Specific Endpoints:** If you have two test accounts (e.g., `userA` and `userB`), log in as `userA` and try to access `userB`'s resources by changing the `id` parameter.
*   **For Administrative Endpoints:** While logged in as a normal user, try to access `/admin/deleteUser.php`. Look for missing access controls.

**B. Test for Injection Flaws:**
*   **SQL Injection:** Use tools like **SQLmap** or manually test parameters with payloads like `'`, `"`, `' OR '1'='1'-- -`.
*   **Command Injection:** For endpoints that might execute system commands (e.g., `/ping?ip=8.8.8.8`), try payloads like `; whoami`, `| id`, `& dir C:\`.
*   **XXE:** If you see XML being sent (e.g., in SOAP APIs), test for XXE by injecting an external entity definition.

**C. Test for Business Logic Flaws:**
*   **Authentication:** Try to bypass the login by using a trailing space in the password (`mypassword `), using `NULL` bytes, or changing the `POST` to a `GET` request.
*   **Payment:** Can you apply a coupon multiple times? Can you set the product price to a negative number via a parameter? (Check for "Mass Assignment").
*   **Rate Limiting:** Can you brute-force the login endpoint without getting blocked?

**D. Test for File-Related Vulnerabilities:**
*   **Path Traversal:** On a file download endpoint like `/download?file=report.pdf`, try `/download?file=../../../../etc/passwd`.
*   **File Upload:** Try uploading a file with a double extension (`shell.php.jpg`), a trailing space (`shell.php `), or with a malicious `Content-Type`.

**E. Test for Server-Side Request Forgery (SSRF):**
*   Look for endpoints that take a URL as a parameter (e.g., `/proxy?url=`, `/fetch?target=`). Try to make the server call internal (`http://localhost`) or your own controlled server.

---

### Phase 3: Tooling and Automation

You cannot do this entirely manually. Automate the repetitive parts.

1.  **Reconnaissance & Organization:**
    *   **Arjun, Parameth:** To find hidden parameters in your endpoints.
    *   **waybackurls, gau (GoLinkFinder):** You might have these already, but they're essential for gathering.
    *   A custom Python script to categorize URLs based on keywords.

2.  **Active Scanning:**
    *   **Burp Suite Professional:** The industry standard. Its active scanner, intruder, and repeater tools are invaluable.
    *   **ffuf, dirsearch:** For further fuzzing on the endpoints you've found (e.g., `api/v1/user/{FUZZ}`).
    *   **Nuclei:** **This is your best friend for a large list.** It has thousands of templated checks for specific CVEs, misconfigurations, and vulnerabilities.
        *   Command: `cat your_endpoints.txt | nuclei -t /path/to/templates -o nuclei_results.txt`

3.  **API-Specific Testing:**
    *   **Postman/Insonmia:** To organize and test API endpoints.
    *   **kiterunner:** Excellent for fuzzing API routes and endpoints that traditional tools miss.

### Sample Workflow for a Single Endpoint

Let's take a hypothetical endpoint: `https://api.target.com/v1/users/123/profile`

1.  **Categorize:** User-Specific, API Endpoint. **High Priority for IDOR.**
2.  **Passive Check:** `GET` the endpoint. Observe the response. Does it return user 123's data? Note the structure.
3.  **IDOR Test:**
    *   Change `123` to `124` in Burp Repeater. Do you get another user's data? **Critical Bug.**
    *   Change the HTTP method from `GET` to `PUT` or `DELETE`. Can you modify or delete other users' data?
4.  **Parameter Testing:**
    *   If it has parameters like `?format=json`, try `?format=../../../../etc/passwd` (Path Traversal) or `?format=<script>alert(1)</script>` (XSS).
    *   Use Arjun to find hidden parameters.
5.  **Automated Scan:**
    *   Send the request to Burp's active scanner.
    *   Run it through Nuclei.
6.  **Document:** Whether you find a bug or not, note it down. A "Not Vulnerable" list is just as important to avoid retesting the same thing.

### Final Pro Tips

*   **Don't Neglect the "Weird":** That `/debug/pprof` endpoint might be leaking goroutine stacks with sensitive data. That `/backup.zip` might contain the source code.
*   **Respect Scope:** Always check the target's bug bounty policy. Do not test out-of-scope assets or use destructive testing (like `DELETE` methods) without permission.
*   **Think Like a Developer:** Ask yourself, "What did the developer assume the user would *never* do?" Then, do that.
*   **Persistence Pays Off:** Finding critical bugs in a huge list is a marathon, not a sprint. Your organized approach will give you a significant edge over others who are just spraying and praying.

Good luck! You have a treasure trove of potential findings. A structured approach will help you mine it effectively.
